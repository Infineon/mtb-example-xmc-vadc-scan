/******************************************************************************
* File Name:   main.c
*
* Description: This is the source code for the XMC MCU: VADC SCAN Example
*              for ModusToolbox. This example shows how to configure ADC for 
*              Continous Scan mode.ADC result is used to change status of LED on kit.
*
* Related Document: See README.md
*
******************************************************************************
*
* Copyright (c) 2015-2021, Infineon Technologies AG
* All rights reserved.                        
*                                             
* Boost Software License - Version 1.0 - August 17th, 2003
* 
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
* 
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
* 
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*                                                                              
*****************************************************************************/

#include "cybsp.h"
#include "cy_utils.h"
#include "xmc_vadc.h"

/*******************************************************************************
* Macros
*******************************************************************************/

/*Define macros for XMC14x Boot kit*/
#ifdef TARGET_KIT_XMC14_BOOT_001
#define RES_REG_NUMBER                 (10)
#define CHANNEL_NUMBER                 (7U)
#define GROUP_NUMBER                   (1U)
#define VADC_GROUP_PTR                 (VADC_G1)
#define VADC_INTERRUPT_EVENT_PRIORITY  3
#define SERVICE_REQUEST_LINE_SR        XMC_VADC_SR_SHARED_SR0
#define INTERRUPT_PRIORITY_NODE_ID     IRQ15_IRQn
#define ADC_CONVERSION_EVENT_HANDLER   IRQ_Hdlr_15
#endif

#define ADC_MEASUREMENT_ICLASS_NUM     (0U)

/*Define macros for XMC47x Relax kit*/
#ifdef TARGET_KIT_XMC47_RELAX_V1
#define RES_REG_NUMBER                 (4)
#define CHANNEL_NUMBER                 (5U)
#define GROUP_NUMBER                   (3U)
#define VADC_GROUP_PTR                 (VADC_G3)
#define VADC_INTERRUPT_EVENT_PRIORITY  63
#define SERVICE_REQUEST_LINE_SR        XMC_VADC_SR_SHARED_SR2
#define INTERRUPT_PRIORITY_NODE_ID     VADC0_C0_2_IRQn
#define ADC_CONVERSION_EVENT_HANDLER   IRQ_Hdlr_16
#endif

/*******************************************************************************
* Global Variables
*******************************************************************************/
static volatile uint32_t g_result_adc_measurement;

/*******************************************************************************
* Data Structure
*******************************************************************************/
/*Initialization data of a VADC Global*/
XMC_VADC_GLOBAL_CONFIG_t g_global_config =
{
    .clock_config =
    {
    .analog_clock_divider    = 1,  /*Clock for the converter*/
    .msb_conversion_clock    = 0,  /*Additional clock cycle for analog converter*/
    .arbiter_clock_divider   = 0   /*Request source arbiter clock divider*/
    },
};

/*Initialization data of a VADC group*/
XMC_VADC_GROUP_CONFIG_t g_group_config =
{
    .class1 =
    {
    .conversion_mode_standard   = XMC_VADC_CONVMODE_12BIT, /*Conversion mode for channels directly connected to VADC*/
    .sample_time_std_conv       = 0U                       /*Sample time for channels directly connected to VADC*/
    }
};

/*Initialization data of a Global iclass0 configuration*/
const  XMC_VADC_GLOBAL_CLASS_t g_global_class =
{
    .conversion_mode_standard   = (uint32_t) XMC_VADC_CONVMODE_12BIT, /*Results of conversion are 12bits wide*/
    .sample_time_std_conv       = (uint32_t) 0                        /*Sample time for channels directly connected to VADC*/
};

/*Initialization data of a VADC Channel*/
XMC_VADC_CHANNEL_CONFIG_t  g_channel_config =
{
    .input_class                = (uint32_t) XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS0,     /*Global ICLASS 0 selected*/
    .lower_boundary_select      = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,  /*Group specific Boundary-0 value*/
    .upper_boundary_select      = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,  /*Group specific Boundary-0 value*/
    .event_gen_criteria         = (uint32_t) XMC_VADC_CHANNEL_EVGEN_NEVER,            /*Channel Event disabled*/
    .sync_conversion            = (uint32_t) 0,                                       /*Sync feature disabled*/
    .alternate_reference        = (uint32_t) XMC_VADC_CHANNEL_REF_INTREF,             /*Internal reference selected*/
    .result_reg_number          = (uint32_t) RES_REG_NUMBER,                          /*GxRES[x] selected*/
    .use_global_result          = (uint32_t) 0,                                       /*Use Group result register*/
    .result_alignment           = (uint32_t) XMC_VADC_RESULT_ALIGN_RIGHT,             /*Result alignment - Right Aligned*/
    .broken_wire_detect_channel = (uint32_t) XMC_VADC_CHANNEL_BWDCH_VAGND,            /*No Broken wire mode select*/
    .broken_wire_detect         = (uint32_t) 0,                                       /*No Broken wire detection*/
    .bfl                        = (uint32_t) 0,                                       /*No Boundary flag*/
    .channel_priority           = (uint32_t) 0,                                       /*Lowest Priority 0 selected*/
    .alias_channel              = (int8_t)   XMC_VADC_CHANNEL_ALIAS_DISABLED          /*ALIAS is Disabled*/
};

/*Initialization data of a VADC Result*/
XMC_VADC_RESULT_CONFIG_t g_result_config =
{
    .data_reduction_control     = (uint8_t)  0,                            /*No Accumulation*/
    .post_processing_mode       = (uint32_t) XMC_VADC_DMM_REDUCTION_MODE,  /*Standard Data reduction mode*/
    .wait_for_read_mode         = (uint32_t) 0,                            /*Disabled*/
    .part_of_fifo               = (uint32_t) 0,                            /*No FIFO*/
    .event_gen_enable           = (uint32_t) 0                             /*Disable Result event*/
};

/*Initialization data of a  Background Scan Init Structure */
const XMC_VADC_BACKGROUND_CONFIG_t g_backgroung_config =
{
    .conv_start_mode   = (uint32_t) XMC_VADC_STARTMODE_CIR,         /*Conversion start mode selected as cancel inject repeat*/
    .req_src_priority  = (uint32_t) XMC_VADC_GROUP_RS_PRIORITY_1,   /*Priority of the Background request source in the VADC module*/
    .trigger_signal    = (uint32_t) XMC_VADC_REQ_TR_A,              /*If Trigger needed then this denotes the Trigger signal*/
    .trigger_edge      = (uint32_t) XMC_VADC_TRIGGER_EDGE_NONE,     /*If Trigger needed then this denotes Trigger edge selected*/
    .gate_signal       = (uint32_t) XMC_VADC_REQ_GT_A,              /*If Gating needed then this denotes the Gating signal*/
    .timer_mode        = (uint32_t) 0,                              /*Timer Mode Disabled*/
    .external_trigger  = (uint32_t) 0,                              /*Trigger is Disabled*/
    .req_src_interrupt = (uint32_t) 1,                              /*Background Request source interrupt Enabled*/
    .enable_auto_scan  = (uint32_t) 1,                              /*Enables the continuous conversion mode*/
    .load_mode         = (uint32_t) XMC_VADC_SCAN_LOAD_OVERWRITE    /*Selects load event mode*/
};

/*******************************************************************************
* Function Name: ADC_CONVERSION_EVENT_HANDLER
********************************************************************************
* Summary:
* This is the interrupt handler function for the ADC after conversion.
*
* Parameters:
*  void
*
* Return:
*  void
*
*******************************************************************************/
void ADC_CONVERSION_EVENT_HANDLER(void)
{
    /*Read out conversion results*/
    g_result_adc_measurement=XMC_VADC_GROUP_GetResult(VADC_GROUP_PTR,RES_REG_NUMBER);

    /*Compare the result counts  */
    if(g_result_adc_measurement >= 2000)
    {
        #ifdef TARGET_KIT_XMC14_BOOT_001
        XMC_GPIO_SetOutputLow(CYBSP_USER_LED_PORT, CYBSP_USER_LED_PIN);
        #endif
        #ifdef TARGET_KIT_XMC47_RELAX_V1
        XMC_GPIO_SetOutputHigh(CYBSP_USER_LED_PORT, CYBSP_USER_LED_PIN);
        #endif
    }
    else
    {
        #ifdef TARGET_KIT_XMC14_BOOT_001
        XMC_GPIO_SetOutputHigh(CYBSP_USER_LED_PORT, CYBSP_USER_LED_PIN);
        #endif
        #ifdef TARGET_KIT_XMC47_RELAX_V1
        XMC_GPIO_SetOutputLow(CYBSP_USER_LED_PORT, CYBSP_USER_LED_PIN);
        #endif
    }
}

/*******************************************************************************
* Function Name: main
********************************************************************************
* Summary:
* This is the main function.
* It sets up a VADC for continuous scan using background scan source.
* ADC result is available after conversion is completed inside event handler function.
* ADC result register value is compared inside event handler function 
* On board LED glows high when ADC counts are more than 2000.
*
* Parameters:
*  none
*
* Return:
*  int
*
*******************************************************************************/
int main(void)
{
    cy_rslt_t result;

    /*Initialize the device and board peripherals*/
    result = cybsp_init();
    if (result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /*Initialize an instance of Global hardware*/
    XMC_VADC_GLOBAL_Init(VADC, &g_global_config);

    /*Initialize Group */
    XMC_VADC_GROUP_Init(VADC_GROUP_PTR, &g_group_config);

    /*Switch on the converter of the Group[group_index]*/
    XMC_VADC_GROUP_SetPowerMode(VADC_GROUP_PTR, XMC_VADC_GROUP_POWERMODE_NORMAL);

    /*Calibrate the VADC. Make sure you do this after all used VADC groups are set to normal operation mode.*/
    XMC_VADC_GLOBAL_StartupCalibration(VADC);

    /*Initialize the Global Conversion class 0*/
    XMC_VADC_GLOBAL_InputClassInit(VADC, g_global_class, XMC_VADC_GROUP_CONV_STD, ADC_MEASUREMENT_ICLASS_NUM);

    /*Initialize the Background Scan hardware*/
    XMC_VADC_GLOBAL_BackgroundInit(VADC, &g_backgroung_config);

    /*Initialize for configured channels*/
    XMC_VADC_GROUP_ChannelInit(VADC_GROUP_PTR, CHANNEL_NUMBER, &g_channel_config);

    /*Initialize for configured result registers*/
    XMC_VADC_GROUP_ResultInit(VADC_GROUP_PTR, RES_REG_NUMBER, &g_result_config);

    /*Add all channels into the Background Request Source Channel Select Register*/
    XMC_VADC_GLOBAL_BackgroundAddChannelToSequence(VADC, GROUP_NUMBER, CHANNEL_NUMBER);

    #ifdef TARGET_KIT_XMC14_BOOT_001
    /*Set Priority for IRQ*/
    NVIC_SetPriority(INTERRUPT_PRIORITY_NODE_ID, VADC_INTERRUPT_EVENT_PRIORITY);
    #endif

    #ifdef TARGET_KIT_XMC47_RELAX_V1
    /*Set Priority for IRQ*/
    NVIC_SetPriority(INTERRUPT_PRIORITY_NODE_ID, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), VADC_INTERRUPT_EVENT_PRIORITY, 0));
    #endif

    /*Connect background Request Source Event to NVIC node*/
    XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode(VADC, SERVICE_REQUEST_LINE_SR);

    /*Enable Background Continuous Scan Request source IRQ*/
    NVIC_EnableIRQ(INTERRUPT_PRIORITY_NODE_ID);

    /*Generate a load event to start background request source continuous conversion*/
    XMC_VADC_GLOBAL_BackgroundTriggerConversion(VADC);

    while(1);
}

/* [] END OF FILE */
